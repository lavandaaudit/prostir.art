<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<title>CYBER ANOMALY GALLERY</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<style>
html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: black;
    font-family: monospace;
}

#info {
    position: absolute;
    display: none;
    color: #00ffff;
    background: rgba(0,0,0,0.7);
    border: 1px solid #00ffff;
    padding: 10px;
    text-shadow: 0 0 6px #00ffff;
    pointer-events: none;
}
</style>
</head>

<body>
<div id="info">
<b>Woman</b><br>
oil on canvas<br>
Roman Katyuschenko<br>
Ukraine, 2013<br>
50 × 70 cm
</div>

<script>
let scene, camera, renderer;
let anomalies = [];
let paintings = [];
let stars;
let info = document.getElementById("info");

init();
animate();

/* ================= INIT ================= */

function init() {
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x000000, 15, 90);

    camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        300
    );
    camera.position.set(0, 2, 20);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    addLight();
    createAnomalies();
    createStars();

    window.addEventListener("resize", onResize);
    document.addEventListener("keydown", navigation);
    document.addEventListener("mousemove", moveInfo);
}

/* ================= LIGHT ================= */

function addLight() {
    scene.add(new THREE.AmbientLight(0x00ffff, 0.3));

    const neon = new THREE.PointLight(0x00ffff, 2, 100);
    neon.position.set(0, 20, 0);
    scene.add(neon);
}

/* ================= ANOMALIES ================= */

function createAnomalies() {
    const radius = 16;

    for (let i = 0; i < 13; i++) {
        const angle = (i / 13) * Math.PI * 2;
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;

        // глітч-стовп
        const pillarGeo = new THREE.CylinderGeometry(0.5, 0.8, 7, 14, 20, true);
        const pillarMat = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            wireframe: true,
            transparent: true,
            opacity: 0.7
        });

        const pillar = new THREE.Mesh(pillarGeo, pillarMat);
        pillar.position.set(x, 3.5, z);
        pillar.userData.index = i;
        anomalies.push(pillar);
        scene.add(pillar);

        // картина
        const tex = new THREE.TextureLoader().load(`${i + 1}.jpg`);
        const pic = new THREE.Mesh(
            new THREE.PlaneGeometry(4, 5),
            new THREE.MeshBasicMaterial({
                map: tex,
                transparent: true,
                opacity: 0
            })
        );
        pic.position.set(x, 3.5, z);
        pic.lookAt(0, 3, 0);
        paintings.push(pic);
        scene.add(pic);
    }
}

/* ================= STARS ================= */

function createStars() {
    const geo = new THREE.BufferGeometry();
    const v = [];

    for (let i = 0; i < 2500; i++) {
        v.push(
            THREE.MathUtils.randFloatSpread(250),
            THREE.MathUtils.randFloatSpread(250),
            THREE.MathUtils.randFloatSpread(250)
        );
    }

    geo.setAttribute("position", new THREE.Float32BufferAttribute(v, 3));
    const mat = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.8 });
    stars = new THREE.Points(geo, mat);
    scene.add(stars);
}

/* ================= ANIMATE ================= */

function animate() {
    requestAnimationFrame(animate);

    stars.rotation.y += 0.0005;

    anomalies.forEach((p, i) => {
        // глітч
        p.rotation.y += 0.01;
        p.position.y = 3.5 + Math.sin(Date.now() * 0.002 + i) * 0.4;
        p.scale.x = 1 + Math.random() * 0.03;
        p.scale.z = 1 + Math.random() * 0.03;

        const d = camera.position.distanceTo(p.position);
        const pic = paintings[i];

        if (d < 6) {
            pic.material.opacity += 0.05;
            p.material.opacity -= 0.05;
            info.style.display = "block";
        } else {
            pic.material.opacity -= 0.05;
            p.material.opacity += 0.05;
            info.style.display = "none";
        }

        pic.material.opacity = THREE.MathUtils.clamp(pic.material.opacity, 0, 1);
        p.material.opacity = THREE.MathUtils.clamp(p.material.opacity, 0.2, 0.8);
    });

    renderer.render(scene, camera);
}

/* ================= NAVIGATION (ТВОЯ) ================= */

function navigation(event) {
    const speed = 0.6;
    const rot = 0.05;

    switch (event.key.toLowerCase()) {
        case "w":
            camera.translateZ(-speed);
            break;
        case "s":
            camera.translateZ(speed);
            break;
        case "a":
            camera.translateX(-speed);
            break;
        case "d":
            camera.translateX(speed);
            break;
        case "e":
            camera.translateY(speed);
            break;
        case "x":
            camera.translateY(-speed);
            break;
        case "arrowleft":
            camera.rotateY(rot);
            break;
        case "arrowright":
            camera.rotateY(-rot);
            break;
    }
}

/* ================= INFO ================= */

function moveInfo(e) {
    info.style.left = e.clientX + 15 + "px";
    info.style.top = e.clientY + "px";
}

/* ================= RESIZE ================= */

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}
</script>
</body>
</html>
