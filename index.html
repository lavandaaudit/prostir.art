<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<title>CYBER GALLERY • Lavanda Audit</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<style>
html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: black;
    font-family: monospace;
}
#info {
    position: absolute;
    color: #0ff;
    background: rgba(0,0,0,0.7);
    border: 1px solid #0ff;
    padding: 10px;
    display: none;
    pointer-events: none;
    text-shadow: 0 0 5px #0ff;
}
</style>
</head>

<body>
<div id="info">
<b>Woman</b><br>
oil on canvas<br>
Roman Katyuschenko<br>
Ukraine, 2013<br>
50 × 70 cm
</div>

<script>
let scene, camera, renderer;
let anomalies = [];
let paintings = [];
let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();
let info = document.getElementById("info");

init();
animate();

function init() {
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x000000, 10, 80);

    camera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.1, 200);
    camera.position.set(0, 3, 20);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0x00ffff, 0.3));
    let neon = new THREE.PointLight(0x00ffff, 2, 50);
    neon.position.set(0, 10, 0);
    scene.add(neon);

    createAnomalies();
    createStars();

    window.addEventListener("resize", onResize);
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("keydown", move);
}

function createAnomalies() {
    const radius = 15;

    for (let i = 0; i < 13; i++) {
        let angle = (i / 13) * Math.PI * 2;
        let x = Math.cos(angle) * radius;
        let z = Math.sin(angle) * radius;

        // глітч-стовп
        let geo = new THREE.CylinderGeometry(0.4, 0.6, 6, 12, 20, true);
        let mat = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            wireframe: true,
            transparent: true,
            opacity: 0.6
        });

        let pillar = new THREE.Mesh(geo, mat);
        pillar.position.set(x, 3, z);
        pillar.userData.index = i;
        anomalies.push(pillar);
        scene.add(pillar);

        // картина
        let tex = new THREE.TextureLoader().load(`${i+1}.jpg`);
        let pic = new THREE.Mesh(
            new THREE.PlaneGeometry(4, 5),
            new THREE.MeshBasicMaterial({
                map: tex,
                transparent: true,
                opacity: 0
            })
        );
        pic.position.set(x, 3, z);
        pic.lookAt(0,3,0);
        paintings.push(pic);
        scene.add(pic);
    }
}

function createStars() {
    let g = new THREE.BufferGeometry();
    let v = [];
    for (let i = 0; i < 2000; i++) {
        v.push(
            THREE.MathUtils.randFloatSpread(200),
            THREE.MathUtils.randFloatSpread(200),
            THREE.MathUtils.randFloatSpread(200)
        );
    }
    g.setAttribute("position", new THREE.Float32BufferAttribute(v, 3));
    let m = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.7 });
    scene.add(new THREE.Points(g, m));
}

function animate() {
    requestAnimationFrame(animate);

    anomalies.forEach((p, i) => {
        // глітч
        p.rotation.y += 0.01;
        p.position.y = 3 + Math.sin(Date.now()*0.002 + i) * 0.3;
        p.scale.x = 1 + Math.random()*0.02;
        p.scale.z = 1 + Math.random()*0.02;

        // дистанція
        let d = camera.position.distanceTo(p.position);
        let pic = paintings[i];

        if (d < 6) {
            pic.material.opacity += 0.05;
            p.material.opacity -= 0.05;
            info.style.display = "block";
        } else {
            pic.material.opacity -= 0.05;
            p.material.opacity += 0.05;
            info.style.display = "none";
        }

        pic.material.opacity = THREE.MathUtils.clamp(pic.material.opacity, 0, 1);
        p.material.opacity = THREE.MathUtils.clamp(p.material.opacity, 0.2, 0.8);
    });

    renderer.render(scene, camera);
}

function onMouseMove(e) {
    mouse.x = (e.clientX / innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / innerHeight) * 2 + 1;
    info.style.left = e.clientX + 15 + "px";
    info.style.top = e.clientY + "px";
}

function move(e) {
    const s = 0.6;
    if (e.key === "w") camera.translateZ(-s);
    if (e.key === "s") camera.translateZ(s);
    if (e.key === "a") camera.translateX(-s);
    if (e.key === "d") camera.translateX(s);
}

function onResize() {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
}
</script>
</body>
</html>
